#!/bin/bash

# This script is a wrapper to the python script
# of the same name.
# It should be sourced, not executed.
# It reads the options/args description from stdin
# and outputs a script which parses the command
# line and performs some automatic checks.

# This wraps the local version of the script
# rather than the installed one, for debugging
# purposes.
# It also allows to optionally inspect the
# generated script.

if [[ -n "${FUNCNAME[0]}" ]]
then
	BASH_OPTPARSE_IS_IN_FUNC="true"
	BASH_OPTPARSE_EXIT_CMD="return"
else
	BASH_OPTPARSE_IS_IN_FUNC="false"
	BASH_OPTPARSE_EXIT_CMD="exit"
fi
export BASH_OPTPARSE_IS_IN_FUNC

[[ -n "$BASH_OPTPARSE_ERR_CODE_MISSING_ITEM" ]] || BASH_OPTPARSE_ERR_CODE_MISSING_ITEM=10;
[[ -n "$BASH_OPTPARSE_ERR_CODE_PARSING_FAILED" ]] || BASH_OPTPARSE_ERR_CODE_PARSING_FAILED=10;

export PYTHONPATH="../src:../build/src:$PYTHONPATH"

BASH_OPTPARSE_PY_SCRIPT_NAME="../src/bash_optparse.py"

[[ -f "$BASH_OPTPARSE_PY_SCRIPT_NAME" ]] || { echo "$(basename $0): error: python script $BASH_OPTPARSE_PY_SCRIPT_NAME not found" >> /dev/stderr; unset BASH_OPTPARSE_IS_IN_FUNC; $BASH_OPTPARSE_EXIT_CMD $BASH_OPTPARSE_ERR_CODE_MISSING_ITEM; }

for BASH_OPTPARSE_REQUIRED_COMMAND in getopt egrep gawk
do
	which "$BASH_OPTPARSE_REQUIRED_COMMAND" &> /dev/null || { echo "$(basename $0): error: $BASH_OPTPARSE_REQUIRED_COMMAND command not found" >> /dev/stderr; unset BASH_OPTPARSE_IS_IN_FUNC; $BASH_OPTPARSE_EXIT_CMD $BASH_OPTPARSE_ERR_CODE_MISSING_ITEM; }
done


BASH_OPTPARSE_OUTPUT_SCRIPT="$(python3 -B $BASH_OPTPARSE_PY_SCRIPT_NAME)"
[[ $? -eq 0 ]] || { unset BASH_OPTPARSE_IS_IN_FUNC; $BASH_OPTPARSE_EXIT_CMD $BASH_OPTPARSE_ERR_CODE_PARSING_FAILED; }

if [[ "$BOP_LOCAL_INSPECT" == "true" ]]
then
	echo "$BASH_OPTPARSE_OUTPUT_SCRIPT"
	unset BASH_OPTPARSE_IS_IN_FUNC
	$BASH_OPTPARSE_EXIT_CMD 0
fi

. <(echo "$BASH_OPTPARSE_OUTPUT_SCRIPT" && unset BASH_OPTPARSE_OUTPUT_SCRIPT)
BASH_OPTPARSE_RETURN_VAL=$?

unset BASH_OPTPARSE_IS_IN_FUNC

[[ -n "${FUNCNAME[0]}" ]] && return $BASH_OPTPARSE_RETURN_VAL
